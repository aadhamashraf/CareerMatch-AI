# -*- coding: utf-8 -*-
"""Copy of gamified_skill_tree_careermatch_ai.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1o-PZPxsEkDSngBJyrq0x15aSl7yeodJi

# Gamified Skill Tree Modeling – CareerMatch-AI

This notebook prototypes a gamified skill tree for CVs and job roles.

Pipeline:

1. Define a canonical skill tree (graph).
2. Define a sample user profile (parsed CV skills).
3. Compute XP per skill from CV evidence.
4. Apply dependency rules → locked / unlocked / completed.
5. Recommend next skills based on target role.
6. (Optional) Visualize the skill graph.
"""

import math
from dataclasses import dataclass, field
from typing import List, Dict

# Optional: for visualization later
try:
    import networkx as nx
    import matplotlib.pyplot as plt
    HAS_VIZ = True
except ImportError:
    HAS_VIZ = False
    print("Visualization libs not installed. Run `pip install networkx` if needed.")

"""## 2. Define the Skill Tree

We represent each skill as a node with:

- `id`
- `name`
- `required_xp`
- `depends_on` (list of skill IDs)
- `roles` (target roles where this skill is essential)

For MVP we hard-code a small tree.
Later this can be loaded from JSON or a database.

"""

@dataclass
class SkillNode:
    skill_id: str
    name: str
    required_xp: int
    depends_on: List[str] = field(default_factory=list)
    roles: List[str] = field(default_factory=list)

# ==== Define a small skill tree for demo ====
SKILL_DEFS: Dict[str, SkillNode] = {
    "python": SkillNode(
        skill_id="python",
        name="Python Programming",
        required_xp=100,
        depends_on=[],
        roles=["data_scientist", "ml_engineer", "backend"]
    ),
    "pandas": SkillNode(
        skill_id="pandas",
        name="Pandas for Data Analysis",
        required_xp=80,
        depends_on=["python"],
        roles=["data_scientist", "data_analyst"]
    ),
    "ml_fundamentals": SkillNode(
        skill_id="ml_fundamentals",
        name="ML Fundamentals",
        required_xp=100,
        depends_on=["python"],
        roles=["data_scientist", "ml_engineer"]
    ),
    "model_deployment": SkillNode(
        skill_id="model_deployment",
        name="Model Deployment",
        required_xp=80,
        depends_on=["ml_fundamentals"],
        roles=["ml_engineer"]
    ),
    "sql": SkillNode(
        skill_id="sql",
        name="SQL for Data",
        required_xp=100,
        depends_on=[],
        roles=["data_analyst", "data_scientist"]
    ),
    "data_viz": SkillNode(
        skill_id="data_viz",
        name="Data Visualization",
        required_xp=80,
        depends_on=["pandas"],
        roles=["data_analyst", "data_scientist"]
    ),
}

"""## 3. User Skill State

For each skill, the user has:

- `current_xp`
- `status`: `"locked" | "unlocked" | "in_progress" | "completed"`

XP will be computed from CV evidence (years, projects, certifications).
For now we simulate a parsed CV with a simple dictionary.

"""

@dataclass
class UserSkillState:
    current_xp: int = 0
    status: str = "locked"  # locked, unlocked, in_progress, completed

# Example: simulated CV evidence per skill
sample_cv_features = {
    "python": {
        "years_experience": 1,
        "num_projects": 2,
        "has_cert": False,
    },
    "pandas": {
        "years_experience": 0.5,
        "num_projects": 1,
        "has_cert": False,
    },
    "sql": {
        "years_experience": 0,
        "num_projects": 0,
        "has_cert": False,
    },
    # ml_fundamentals, model_deployment, data_viz are missing from CV
}

"""## 4. XP Computation

We define a simple heuristic:

- Each year of experience → up to 50 XP
- Each project → up to 30 XP
- Certification → +20 XP

Then cap at the skill's `required_xp`.

This is just a baseline; you should tune it later according to your scoring system (Strength, etc.).

"""

def compute_initial_xp_for_skill(skill_id: str, cv_features: Dict) -> int:
    """Compute XP for one skill from CV features."""
    feat = cv_features.get(skill_id)
    if not feat:
        return 0

    years = feat.get("years_experience", 0)
    projects = feat.get("num_projects", 0)
    has_cert = feat.get("has_cert", False)

    xp = 0
    xp += min(50, years * 20)       # up to 2.5 years → 50 XP
    xp += min(30, projects * 10)    # up to 3 projects → 30 XP
    xp += 20 if has_cert else 0

    required = SKILL_DEFS[skill_id].required_xp
    return int(min(xp, required))

def build_user_state_from_cv(cv_features: Dict[str, Dict]) -> Dict[str, UserSkillState]:
    """Create UserSkillState dict for all skills in SKILL_DEFS."""
    user_state: Dict[str, UserSkillState] = {}

    for sid, node in SKILL_DEFS.items():
        xp = compute_initial_xp_for_skill(sid, cv_features)
        user_state[sid] = UserSkillState(current_xp=xp)

    return user_state

user_state = build_user_state_from_cv(sample_cv_features)
user_state

"""## 5. Dependency Logic & Status

Rules (MVP):

- If `current_xp >= required_xp` → `completed`
- Else if all dependencies are **completed or ≥ 70% XP** → `unlocked`
- Else if no dependencies → `unlocked`
- Otherwise → `locked`

"""

def is_unlocked(skill_id: str, user_state: Dict[str, UserSkillState]) -> bool:
    node = SKILL_DEFS[skill_id]
    if not node.depends_on:
        return True  # root skills

    for dep_id in node.depends_on:
        dep_node = SKILL_DEFS[dep_id]
        dep_state = user_state.get(dep_id, UserSkillState())
        threshold = 0.7 * dep_node.required_xp
        if dep_state.current_xp < threshold:
            return False
    return True

def update_statuses(user_state: Dict[str, UserSkillState]) -> None:
    for sid, node in SKILL_DEFS.items():
        state = user_state[sid]
        if state.current_xp >= node.required_xp:
            state.status = "completed"
        elif is_unlocked(sid, user_state):
            state.status = "in_progress" if state.current_xp > 0 else "unlocked"
        else:
            state.status = "locked"

update_statuses(user_state)

for sid, state in user_state.items():
    print(f"{sid:18} XP={state.current_xp:3} / {SKILL_DEFS[sid].required_xp:3}  → {state.status}")

"""## 6. Role-Aware Recommendations

Given a target role (e.g. `"data_scientist"`):

1. Consider skills:
   - status == `"unlocked"` or `"in_progress"`
   - and skill is tagged with the target role.
2. Score each candidate by:
   - gap to required XP = `required_xp - current_xp`.
3. Sort by largest gap (biggest missing pieces first).

"""

def recommend_next_skills(
    user_state: Dict[str, UserSkillState],
    target_role: str,
    top_k: int = 3,
):
    candidates = []
    for sid, node in SKILL_DEFS.items():
        state = user_state[sid]
        if target_role not in node.roles:
            continue
        if state.status not in ("unlocked", "in_progress"):
            continue
        gap = node.required_xp - state.current_xp
        if gap <= 0:
            continue
        candidates.append((gap, sid))

    candidates.sort(reverse=True)  # largest gap first
    return [sid for _, sid in candidates[:top_k]]

target_role = "data_scientist"
next_skills = recommend_next_skills(user_state, target_role)

print(f"Target role: {target_role}")
print("Recommended next skills:")
for sid in next_skills:
    node = SKILL_DEFS[sid]
    state = user_state[sid]
    print(
        f"- {node.name} (XP {state.current_xp}/{node.required_xp}, status={state.status})"
    )

"""## 7. Optional: Visualize the Skill Tree

We use `networkx` + `matplotlib` to show:

- Nodes with labels including status
- Edges as dependencies

"""

if not HAS_VIZ:
    print("Install networkx & matplotlib to enable visualization.")
else:
    G = nx.DiGraph()
    for sid, node in SKILL_DEFS.items():
        state = user_state[sid]
        label = f"{sid}\n({state.status})"
        G.add_node(sid, label=label)

        for dep in node.depends_on:
            G.add_edge(dep, sid)

    pos = nx.spring_layout(G, seed=42)

    plt.figure(figsize=(8, 6))
    nx.draw(G, pos, with_labels=True, labels={n: G.nodes[n]['label'] for n in G.nodes()})
    plt.title("Skill Tree")
    plt.axis("off")
    plt.show()

"""## 8. Hook Point for Your Backend

In your real system, replace `sample_cv_features` with features from your CV parser and wrap the logic into a function like:

```python
def build_skill_tree_for_user(cv_features, target_role):
    user_state = build_user_state_from_cv(cv_features)
    update_statuses(user_state)
    recommendations = recommend_next_skills(user_state, target_role)
    return user_state, recommendations
```

Then call this from your API and send the resulting data structure to the frontend.

"""